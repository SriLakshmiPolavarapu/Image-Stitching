# -*- coding: utf-8 -*-
"""Image_Stitch

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PTpU25UdsTM0tfTXHFT8ttb2k7pND_zy
"""

import cv2
import sys
import numpy as np
from random import randint
from numpy.linalg import inv

def ex_find_homography_ransac(list_pairs_matched_keypoints, threshold_ratio_inliers=0.85, threshold_reprojtion_error=3, max_num_trial=1000):

    best_H = None

    print("len list_pair_matched keypoints :", len(list_pairs_matched_keypoints))
    for pair in list_pairs_matched_keypoints:
        pt1 = pair[0]
        pt1.append(1)
        pt2 = pair[1]
        pt2.append(1)

    max_inliers = 0
    listH = []
    for num in range(0,max_num_trial):
        A =[]
        points4 = []
        otherH = []
        for i in range(4):
            index = randint(0,len(list_pairs_matched_keypoints)-1)
            points4.append(list_pairs_matched_keypoints[index])
            x = points4[i][0][0]
            y = points4[i][0][1]
            u = points4[i][1][0]
            v = points4[i][1][1]

            A.append([x,y,1,0,0,0, -u*x, -u*y, -u])
            A.append([0,0,0,x,y,1,-v*x,-v*y,-v])
        A = np.asarray(A)

        U,S,V = np.linalg.svd(A)
        last =V[-1,:]
        H = last.reshape(3,3)

        inliers = []
        for point_pair in list_pairs_matched_keypoints:
            p1 = np.asarray(point_pair[0])
            p2 = np.asarray(point_pair[1])
            projected_p2 = np.dot(H,p1)
            projected_p2 /= projected_p2[2]

            error = np.linalg.norm(p2 - projected_p2)
            if(error < threshold_reprojtion_error):
                inliers.append(point_pair)

        otherH.append(H)
        otherH.append(len(inliers)/len(list_pairs_matched_keypoints))
        listH.append(otherH)

        if((len(inliers) / len(list_pairs_matched_keypoints)) > threshold_ratio_inliers):
            if(len(inliers) > max_inliers):
                max_inliers = len(inliers)
                A = []
                for point in inliers:
                    x = point[0][0]
                    y = point[0][1]
                    u = point[1][0]
                    v = point[1][1]

                    A.append([x,y,1,0,0,0,-u*x,-u*y,-u])
                    A.append([0,0,0,x,y,1,-v*x,-v*y, -v])
                A = np.asarray(A)
                U,S,V = np.linalg.svd(A)
                last = V[-1,:]
                newH = last.reshape(3,3)

                best_H = newH

    if(best_H is None):
        listH.sort(key=lambda x: x[1])
        print("best_H not found in 1000 trials")
        best_H = listH[0][0]

    return best_H

def ex_extract_and_match_feature(img_1, img_2, ratio_robustness=0.7):

    img_11 = cv2.cvtColor(img_1,cv2.COLOR_BGR2GRAY)
    img_22 = cv2.cvtColor(img_2,cv2.COLOR_BGR2GRAY)

    sift = cv2.xfeatures2d.SIFT_create()
    kp1,des1 = sift.detectAndCompute(img_11,None)
    pts1 = [kp1[i].pt for i in range(len(kp1))]
    sift = cv2.xfeatures2d.SIFT_create()
    kp2,des2 = sift.detectAndCompute(img_22,None)
    pts2 = [kp2[i].pt for i in range(len(kp2))]


    list_pairs_matched_keypoints = []

    for i in range(len(des1)):
        error = []
        for j in range(len(des2)):
            point=[]
            point.append(list(pts2[j]))
            val = np.linalg.norm(des1[i] - des2[j])
            point.append(val)
            error.append(point)
        error.sort(key=lambda distance: distance[1])
        if(error[0][1]/error[1][1] < 0.7):
            matched_points = []
            matched_points.append(list(pts1[i]))
            matched_points.append(error[0][0])
            list_pairs_matched_keypoints.append(matched_points)

    return list_pairs_matched_keypoints

def ex_warp_blend_crop_image(img_1,H_1,img_2):

    img_panorama = None
    h, w, z = img_1.shape
    point = [img_1.shape[1],img_1.shape[0],1]
    warpShape = np.dot(H_1,point)
    warpShape = warpShape/warpShape[2]

    h = int(1.55*np.floor(warpShape[0]))
    w = int(0.72*np.floor(warpShape[1]))

    warp = np.zeros((h,w+img_2.shape[1],3))
    result = np.zeros((h,w+img_2.shape[1]))

    for y in range(-100,h):
        for x in range(-100,w):
            xy = np.dot(np.linalg.inv(H_1),[x,y,1])
            xy = xy/xy[2]
            xp = int(np.floor(xy[0]))
            yp = int(np.floor(xy[1]))
            if yp < result.shape[0] and yp >= 0 and xp < result.shape[1] and xp>=0:
                a = xy[0] - xp
                b = xy[1] - yp
                if(yp+1 < img_1.shape[0] and xp+1 < img_1.shape[1]):
                    bilateral = ((1-a)*(1-b))*(img_1[yp,xp]) + (a*(1-b))*(img_1[yp,xp+1])+(a*b)*(img_1[yp+1,xp+1])+((1-a)*b)*(img_1[yp+1,xp])
                    warp[y+33][x+101] = bilateral

    h2 = img_2.shape[0]
    w2 = img_2.shape[1]
    for y in range(h2):
        for x in range(w2):
            p2 = img_2[y][x]
            p1 = warp[y+33][x+101]
            if(p1[0] == 0 and p1[1] == 0 and p1[2] == 0):
                warp[y+33][x+101] = img_2[y][x]
            else:
                sum = p1+p2
                avg = [sum[0]/2, sum[1]/2, sum[2]/2]
                warp[y+33][x+101] = avg

    img_panorama = warp
    return img_panorama

def stitch_images(img_1, img_2):

    list_pairs_matched_keypoints = ex_extract_and_match_feature(img_1=img_1, img_2=img_2, ratio_robustness=0.7)

    H_1 = ex_find_homography_ransac(list_pairs_matched_keypoints, threshold_ratio_inliers=0.85, threshold_reprojtion_error=3, max_num_trial=1000)

    img_panorama = ex_warp_blend_crop_image(img_1=img_1,H_1=H_1, img_2=img_2)

    return img_panorama

if __name__ == "__main__":

    path_file_image_1 = "/content/image.jpeg"
    path_file_image_2 = "/content/image1.jpeg"
    path_file_image_result = "/content/output_panorama_1.jpeg"

    img_1 = cv2.imread(path_file_image_1)
    img_2 = cv2.imread(path_file_image_2)

    img_panorama = stitch_images(img_1=img_1, img_2=img_2)

    cv2.imwrite(filename=path_file_image_result, img=img_panorama)